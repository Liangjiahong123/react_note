# React简介

- **概念：**`React` 是将数据渲染为 `HTML` 视图的开源 `JavaScript` 库，用于构建用户界面，由组件组成，拥有自己的逻辑和外观
- **作者：**`Facebook` 的软件工程师 `Jordan Walke`

- **官网：**https://zh-hans.react.dev/
- **特点：**声明式、组件化、跨平台
  - **声明式编程：**目前整个大前端开发的模式，如 `Vue`、`React`等，允许只需维护自己的状态，当状态改变时，`React` 可以根据最新状态渲染 `UI` 界面
  - **组件化开发：**当前前端的流行趋势，将复杂的界面拆分成一个个小组件
  - **多平台适配：**2013年`React` 主要是开发 `Web` 页面；2015 年`ReactNative` 用于开发移动端跨平台；2017 年`ReactVR` 用于开发虚拟现实 `Web` 应用程序
- **开发依赖：**`react`、`react-dom`、`babel`
  - **`react`：**包含 `react` 所必须的核心代码
  - **`react-dom`：**`react` 渲染在不同平台所需的核心代码
  - **`babel`：**将 `jsx` 转换成 `React` 代码的工具

# React初体验

- 使用 `CDN` 引入依赖

```html
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
```

- 创建一个根元素

```html
<div id="root"></div>
```

- 在浏览器上渲染 `Hello React`

```javascript
<script type="text/babel"> // 告诉浏览器使用babel转换，否则无法解析
  // React18之前的写法
  // ReactDOM.render(<h2>Hello React</h2>, document.querySelector('#root'))

  // React18之后的写法
  const root = ReactDOM.createRoot(document.querySelector('#root'))
	// 使用jsx语法，其内部会调用React.createElement方法
  root.render(<h2>Hello React</h2>)
</script>
```

- **`JSX` 语法：**即 `JavaScript XML`，一种在 `React` 组件内部构建标签的类 `XML` 语法，`react` 的语法糖

![1686159514133](images/1686159514133.png)

- 实现点击按钮，改变文本为 `Hello React,Welcome`

```javascript
const root = ReactDOM.createRoot(document.querySelector('#root')) // 创建根元素

let message = 'Hello React' // 定义所改变的数据

// 将渲染封装成一个函数
const rootRender = () => {
  root.render((
    <div>
      <h2>{message}</h2>
      <button onClick={handleChangeText}>修改文本</button>
    </div>
  ))
}

rootRender() // 初始调用

// 按钮点击函数
const handleChangeText = () => {    
  message = 'Hello React，Welcome'  // 修改数据
  rootRender()   // 手动重新渲染
}
```

- **注意：**这里需要手动调用一次 `render` 函数，和 `Vue` 不一样的是，`Vue` 数据变了之后会自动重新渲染模板，过程是不可见的，但 `React` 需要手动调用，整个过程是可见的

# 组件化开发

- `root.render` 参数是一个 `HTML` 元素或者一个组件，那么可以将之前的逻辑封装到一个组件中，然后传入到`ReactDOM.render` 函数中的第一个参数

- 使用类组件进行重构

  1. **创建组件：**定义一个类并继承自 `React.Component`，类名须大写(小写则是 `HTML` 元素)

  2. **实现 `render`：**实现组件的 `render` 函数，函数返回 `JSX` 内容，即渲染的内容
  3. **定义数据：**数据可根据是否参与界面更新分为两种类型
     - **参与数据流：**数据参与界面更新，则定义在构造函数的 `state` 中，`this.state = {数据}`，数据发生变化时，调用 `this.setState` 更新数据，并且通知 `React` 进行 `update` 操作，此时会重新调用 `render` 函数，并使用最新数据渲染界面

```jsx
// 创建根元素
const root = ReactDOM.createRoot(document.querySelector('#root'))
// 定义一个类并继承React.Component
class APP extends React.Component {
  // 组件数据
  constructor() {
    super()
    this.state = {  // 这里必须是state
      message: 'Hello React'
    }
    // 因为这里使用了babel转换，会将handleChangeText方法中的this转为undefined
    // 因此事件绑定需显示绑定实例的this
    this.handleChangeText = this.handleChangeText.bind(this)
  }

  // 组件方法
  handleChangeText() {
    // setState方法内部完成两件事情：
    // 1、将state中的数据更新；2、自动重新执行render函数
    this.setState({
      message: 'Hello React，Welcome'
    })
  }

  // 渲染内容，使用render方法
  render() {
    return (
      <div>
        <h2>{this.state.message}</h2>
        <button onClick={this.handleChangeText}>修改文本</button>
      </div>
    )
  }
}
// 渲染组件
root.render(<APP />)
```

- 用类组件实现一个小电影列表

```jsx
const root = ReactDOM.createRoot(document.querySelector('#root'))

class App extends React.Component {
  constructor() {
    super()
    this.state = {
      movies: ['满江红', '流浪地球2', '无名', '毒舌律师']
    }
  }

  render() {
    return (
      <div>
        <h2>电影列表</h2>
        <ul>
          {this.state.movies.map((movie, i) => <li key={i}>{movie}</li>)}
        </ul>
      </div>
    )
  }
}

root.render(<App />)
```
